# fastAPI_app/Dockerfile

# --- Базовый образ ---
# Используем официальный образ Python. Рекомендуется использовать slim-версию
# для уменьшения размера итогового образа. Укажите версию Python,
# которую вы использовали при разработке (например, 3.9, 3.10, 3.11).
FROM python:3.9-slim

# --- Установка переменных окружения ---
# PYTHONUNBUFFERED: Гарантирует, что вывод Python (например, print)
# сразу отправляется в терминал/логи, что полезно для отладки в Docker.
ENV PYTHONUNBUFFERED 1
# PIP_NO_CACHE_DIR: Отключает кэширование pip при использовании флага --no-cache-dir.
# Сама по себе переменная ENV PIP_NO_CACHE_DIR=on или off менее стандартна, чем флаг у pip.
# Оставим ее как напоминание, но основное - флаг у pip install.
ENV PIP_NO_CACHE_DIR_GLOBAL off # Переименовал для ясности, что это глобальная попытка, но флаг важнее
# PYTHONDONTWRITEBYTECODE: Предотвращает создание .pyc файлов Python,
# что также может немного сэкономить место, если это не критично для производительности.
ENV PYTHONDONTWRITEBYTECODE 1

# --- Установка системных зависимостей (включая curl) ---
# Обновляем список пакетов и устанавливаем curl.
# -y автоматически отвечает "yes" на запросы подтверждения.
# && rm -rf /var/lib/apt/lists/* очищает кэш apt после установки,
# чтобы уменьшить размер слоя образа.
RUN apt-get update && apt-get install -y curl \
    && rm -rf /var/lib/apt/lists/*

# --- Установка рабочей директории ---
# Все последующие команды будут выполняться относительно этой директории.
# Также это директория, куда будет скопирован код приложения.
WORKDIR /app

# --- Установка зависимостей Python ---
# 1. Копируем только файл requirements.txt.
#    Это позволяет Docker кэшировать этот слой, если requirements.txt не изменился,
#    что ускоряет последующие сборки, если меняется только код приложения.
COPY ./requirements.txt /app/requirements.txt

# 2. Обновляем pip и устанавливаем зависимости.
#    --no-cache-dir здесь также помогает уменьшить размер слоя.
RUN pip install --no-cache-dir --upgrade pip \
    && pip install --no-cache-dir -r requirements.txt

# --- Копирование кода приложения ---
# Копируем все содержимое текущей директории (где находится Dockerfile,
# то есть ./fastAPI_app) в рабочую директорию /app внутри контейнера.
COPY . /app

# --- Открытие порта ---
# Сообщаем Docker, что приложение внутри контейнера будет слушать на порту 8000.
# Это не публикует порт на хост-машину автоматически, это делается
# в docker-compose.yml с помощью секции 'ports'.
EXPOSE 8000

# --- Команда для запуска приложения ---
# Запускаем Uvicorn ASGI сервер для обслуживания FastAPI приложения.
# main:app - указывает на объект 'app' в файле 'main.py'.
# --host 0.0.0.0 - делает сервер доступным извне контейнера (внутри сети Docker).
# --port 8000 - порт, на котором Uvicorn будет слушать внутри контейнера.
# --reload - (Опционально, для разработки) Автоматически перезагружает сервер
#            при изменениях в коде. Для продакшена этот флаг следует убрать
#            и, возможно, увеличить количество воркеров (--workers).
#            Если используется --reload, то в docker-compose.yml нужно
#            монтировать volume с кодом (что мы и сделали: - ./fastAPI_app:/app).
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]

# Для продакшен-сборки команда может выглядеть так:
# CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000", "--workers", "4"]
# (Количество воркеров зависит от ресурсов и ожидаемой нагрузки)